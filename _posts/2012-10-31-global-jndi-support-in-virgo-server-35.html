---
layout: post
title: Global JNDI support in Virgo Server 3.5 for Tomcat
date: '2012-10-31T09:04:00.000+01:00'
author: Giamma
tags:
- JNDI
- EclipseLink
- Tomcat
- Virgo
- OSGi
- Eclipse
modified_time: '2012-10-31T13:39:18.913+01:00'
blogger_id: tag:blogger.com,1999:blog-7876506089821014047.post-5066249955985592072
blogger_orig_url: https://devshards.blogspot.com/2012/10/global-jndi-support-in-virgo-server-35.html
---

<div><br />This rather long post analyses four solutions to the problem of using data sources,  and more in general JNDI in Virgo, the 4th being the one I recommend  and decided to use, which consists in leveraging Tomcat's built-in JNDI provider in Eclipse Virgo Server for Apache Tomcat.<br /><br />If you are not interested in the reasons why I  dropped the first three, jump directly to the fourth.<br /><br />Even if the post is mostly focused on JDBC data sources, once Tomcat JNDI provider is exposed to the application it can be used for any type of resource, not only data sources. <br /><br />Most of the credits for this solution go to my colleague Stefano Malimpensa.<br /><br /><h2><b>1. JDBC </b><b>data sources in OSGi</b> </h2>The most correct approach to obtain a JDBC data source in a pure OSGi enterprise application consists in using the OSGi JDBC Service (see the official OSGi <a href="http://www.osgi.org/Download/File?url=/download/r4v42/r4.enterprise.pdf" target="_blank">JDBC specification</a>).&nbsp; In Virgo, that means using <a href="http://www.eclipse.org/gemini/dbaccess/" target="_blank">Gemini DBAccess</a>.<br /><br />However, in my humble opinion Gemini DBAccess is not an optimal solution for a number of&nbsp; reasons:<br /><br /><ol type="1"></ol><ul><li> Gemini DBAccess is currently available  only for Derby, and to use a different database you need to write your own implementation. Not a big issue but some extra effort anyway.<br /></li><li> To integrate DBAccess with EclipseLink you should probably use <a href="http://www.eclipse.org/gemini/jpa/" target="_blank">Gemini JPA</a>, which is affected by a bug that prevents connection pooling  from working and is therefore not usable in production <a href="https://bugs.eclipse.org/bugs/show_bug.cgi?id=379397">https://bugs.eclipse.org/bugs/show_bug.cgi?id=379397</a><br /></li><li> When using DBAccess with Gemini JPA you need configure  connection parameters in each bundle's persistence.xml. I find this inconvenient because it is necessary to repackage the bundles every time the  connection parameters change, and due to the modular nature of OSGi one complex application may include several bundles with persistence units.<br /></li><li>If DBAccess is used without GeminiJPA, DBAccess will  provide only a data source factory, and it will be the responsibility of your code to  instantiate and configure the data source (e.g. pass in user name, password etc). In such case you would need to support a  configuration file to let system administrators easily change  connnection parameters, which is again extra effort.</li><li>DBAccess requires the  OSGi registry, which means it would not work with legacy code or third  party libraries written for J2EE.&nbsp;</li></ul><ol type="1">    </ol>As the name implies, Gemini DBAccess is tailored to data base  resources. If you want a single, unified approach for looking up any type  of resource, then it's not a good fit for you.<br /><br /><h2><b>2. Full JNDI in OSGi</b> </h2>&nbsp;At this point you may want to try <a href="http://www.eclipse.org/gemini/naming/" target="_blank">Gemini Naming</a>,&nbsp; which implements the OSGi<a href="http://www.osgi.org/Download/File?url=/download/r4v42/r4.enterprise.pdf" target="_blank"> JNDI service specification</a>. Even Gemini Naming is in my humble opinion not an optimal solution:<br /><ol></ol><ul><li>There is no configuration console, nor a configuration file: the only way you can bind resources in the JNDI namespace is programmatically. This implies a lot of boring initialisation code, and you probably need to support a  configuration file to let system administrators easily change configuration parameters, which is again extra effort. </li><li>Gemini Naming requires the  OSGi registry, which means it would not work with legacy code or third  party libraries written for J2EE. </li></ul><ol> </ol><br /><h2><b>3. Local JNDI declared inside a Web App</b></h2><br />Virgo supports JNDI lookups for data sources inside a Web App. To achieve this you have to:<br /><ol></ol><ul><li>Include in the Web application the JDBC driver(s) and the pool implementation (e.g. Apache DBCP or Tomcat JDBC) as jars in your WEB-INF/lib folder</li><li>Configure web.xml to list the usual JNDI resource-refs</li><li>Include a Tomcat context.xml file in the Web App and configure it as explained <a href="http://www.eclipse.org/virgo/documentation/virgo-documentation-3.5.0.RELEASE/docs/virgo-user-guide/htmlsingle/virgo-user-guide.html#configuring-tomcat" target="_blank">here</a> and <a href="http://tomcat.apache.org/tomcat-7.0-doc/config/context.html#Resource_Definitions" target="_blank">here </a></li></ul><ol>  </ol>The above will work for JDBC data sources but has the following draw backs:<br /><ul><li>You must include the JDBC driver and pool in every Web App of yours. This means that each Web App will have its own pool, even if they connect to the same database, and that you must repackage the WAR if you need to update the JDBC driver</li><li>JNDI lookup will work only in a thread originated by a HTTP request. This means that application bundles that are not WARs will not be able to obtain the data source via a JNDI lookup, unless their code is executed by a thread started by the Web container. In fact, the JNDI lookup will fail from threads created by Equinox: this is for example the case of code that observes OSGi framework lifecycle events (BundleListener) and need access the database when a bundle is installed or uninstalled.</li></ul>In my case the main show stopper to this solution is the thread issue described above, because my application must access the database (and therefore the data source) from threads that are not always started by the Web container. If you are interested in the historical roots of this apparently strange limitation, I recommend reading <a href="http://njbartlett.name/2012/10/23/dreaded-thread-context-classloader.html" target="_blank">this post</a> by Neil Bartlett.<br /><br /><h2><b>4. Tomcat global JNDI registry</b></h2><br />Another option is available, which is not affected by any of the above issues and limitations and it consists in using Tomcat's global JNDI  support. You gain a general purpose well tested and well documented JNDI  registry capable of deploying any type of resource, not only  data-sources (can even be extended to support custom resource types <a href="http://tomcat.apache.org/tomcat-6.0-doc/jndi-resources-howto.html#Adding_Custom_Resource_Factories">http://tomcat.apache.org/tomcat-6.0-doc/jndi-resources-howto.html#Adding_Custom_Resource_Factories</a>).<br /><br />Please note that this solution will make the global JNDI namespace available, disabling the Web App <b>java:comp/env</b> context. In order words, you cannot use the java:comp/env prefix in your JNDI lookups. This should be an acceptable limitation, given that the java:comp/env prefix in any case would work only within a Web App and not from a plain OSGi bundle.<br /><br />In order to use the Tomcat&nbsp; JNDI registry for data sources in Virgo the following mandatory steps are required:<br /><br /><ol><li>Create a bundle fragment for Catalina to extend Virgo's Tomcat with connection pooling support. The Virgo distribution contains in fact a stripped down version of Tomcat that removes the libraries required for JDBC pooling. Luckily enough, you can create a fragment to contribute the libraries back to Catalina. You just need to make sure that your fragments are placed in the bundle repository folder, not in pickup. </li><li>Create a bundle fragment for Catalina to make the required JDBC driver(s) available to the server and the application</li><li>Create a fragment that gets the JNDI context from Tomcat and that registers in the JVM a global <a href="http://docs.oracle.com/javase/1.4.2/docs/api/javax/naming/spi/InitialContextFactoryBuilder.html" target="_blank">InitialContextFactoryBuilder</a> </li><li>Edit tomcat-server.xml and define your global resources</li></ol><h4><span style="font-weight: normal;">All the above fragments are a convenient method for extending Tomcat/Catalina to use third party libraries whose Java packages were not originally imported by the Virgo bundles. For further details refer to <a href="http://underlap.blogspot.it/2011/03/importing-packages-into-3rd-party.html" target="_blank">this post</a> by Glyn Normington, the project lead of Virgo. If you are working with Virgo his personal blog is a must read!</span></h4><br/><br/><h4>1. The pool bundle fragment</h4>Here is a sample for Apache DBCP. The MANIFEST.MF below is added to the DBCP  JAR, that's why there is no Bundle-Classpath.  Mind the fragment host header.<br /><br /><pre class="brush: bash;">Manifest-Version: 1.0<br />Fragment-Host: com.springsource.org.apache.catalina<br />Bundle-ManifestVersion: 2<br />Bundle-Name: Tomcat DBCP<br />Bundle-SymbolicName: org.apache.tomcat.dbcp<br />Bundle-Version: 7.0.27<br />Bundle-Vendor: apache<br />Bundle-RequiredExecutionEnvironment: JavaSE-1.6<br />Import-Package: javax.management,<br /> javax.management.openmbean,<br /> javax.naming,<br /> javax.sql,<br /> org.apache.juli.logging<br /></pre><br /><br/><h4>2. The JDBC driver bundle fragment</h4>Here is a sample for PostgreSQL. The MANIFEST.MF below is added to the PostgreSQL driver JAR, that's why there is no Bundle-Classpath.  Mind the fragment host header.<br /><br /><pre class="brush: bash;">Manifest-Version: 1.0<br />Fragment-Host: com.springsource.org.apache.catalina<br />Bundle-ManifestVersion: 2<br />Bundle-Name: PostgreSQL JDBC Driver<br />Bundle-SymbolicName: org.postgresql.jdbc.catalina<br />Bundle-Version: 9.2.1000<br />Bundle-Vendor: postgresql<br />Bundle-RequiredExecutionEnvironment: JavaSE-1.6<br /></pre><br /><br/><h4>3. JNDI bridge fragment</h4>Create a fragment with the following MANIFEST.MF that includes the two classes below and place it in the repository folder.<br /><br /><pre class="brush: bash;">Manifest-Version: 1.0<br />Bundle-ManifestVersion: 2<br />Bundle-Name: JNDITomcatBridge<br />Bundle-SymbolicName: jndi.tomcat.bridge<br />Bundle-Version: 1.0.0.qualifier<br />Bundle-Vendor: org.example<br />Fragment-Host: com.springsource.org.apache.catalina;bundle-version="7.0.26"<br />Bundle-RequiredExecutionEnvironment: JavaSE-1.6<br />Import-Package: org.apache.catalina.mbeans;version="7.0.26"<br /></pre><br />The code below consists of two classes.<br /><br />The first, GlobalJNDILifecycleListener, is a GlobalResourcesLifecycleListener subclass that downcasts the server instance to get the global JNDI context and that registers in the JVM NamingManager a custom InitialContextFactoryBuilder which wraps the JNDI context obtained from Tomcat.<br /><br />Other options are of course possible, including doing everything in the custom implementation of InitialContextFactoryBuilder without subclassing the listener, but whatever approach you adopt, it is important to make sure that the invocation to NamingManager.setInitialContextFactoryBuilder occurs only once in the life of a Virgo server instance, because the method will fail and raise a runtime exception if it is called more than once. <br /><br /><br /><pre class="brush: java;">import javax.naming.Binding;<br />import javax.naming.Context;<br />import javax.naming.NamingEnumeration;<br />import javax.naming.NamingException;<br />import javax.naming.spi.NamingManager;<br /><br />import org.apache.catalina.Lifecycle;<br />import org.apache.catalina.LifecycleEvent;<br />import org.apache.catalina.Server;<br />import org.apache.catalina.mbeans.GlobalResourcesLifecycleListener;<br />import org.apache.juli.logging.Log;<br />import org.apache.juli.logging.LogFactory;<br /><br />public class GlobalJNDILifecycleListener extends GlobalResourcesLifecycleListener {<br />    private static final Log log = LogFactory.getLog(GlobalJNDILifecycleListener.class);<br /><br />    @Override<br />    public void lifecycleEvent(LifecycleEvent event) {<br />        super.lifecycleEvent(event);<br />        if (Lifecycle.START_EVENT.equals(event.getType())) {<br />            Server server = (Server) event.getLifecycle();<br />            Context ctx = server.getGlobalNamingContext();<br />            ContextFactory factory = new ContextFactory(ctx);<br />            try {                <br />                NamingManager.setInitialContextFactoryBuilder(factory);<br />                log.info("Published Global Naming as default InitialContext");<br />                logJNDIEntries(ctx, null);<br />            } catch (NamingException e) {<br />                log.error("Naming Exception:", e);<br />            }<br />        }<br /><br />    }<br /><br />    private void logJNDIEntries(Context context, String prefix) throws NamingException {<br /><br />        NamingEnumeration&lt;Binding> namingEnumeration = context.listBindings("");<br /><br />        while (namingEnumeration.hasMoreElements()) {<br />            Binding binding = namingEnumeration.next();<br />            String nameEntry = binding.getName();<br />            String fullName = (prefix == null || prefix.equals("") ? nameEntry : prefix + "/" + nameEntry);<br />            String entryClassName = binding.getClassName();<br />            if (Context.class.getName().equals(entryClassName)) {<br />                Context ctx = (Context) binding.getObject();<br />                logJNDIEntries(ctx, fullName);<br />            } else {<br />                log.info("Found: " + fullName);<br />            }<br />        }<br />    }<br /><br />}</pre> <pre class="brush: java;">import java.util.Hashtable;<br /><br />import javax.naming.Context;<br />import javax.naming.InitialContext;<br />import javax.naming.NamingException;<br />import javax.naming.spi.InitialContextFactory;<br />import javax.naming.spi.InitialContextFactoryBuilder;<br /><br />/**<br /> * Simple implementation of {@link InitialContextFactory} that returns the global {@link InitialContext}<br /> * obtained from Tomcat<br /> *<br /> * @author giamma, stefano<br /> *<br /> */<br />public class ContextFactory implements InitialContextFactoryBuilder, InitialContextFactory {<br /><br />    private Context context;<br /><br />    public ContextFactory(Context context) {<br />        this.context = context;<br />    }<br />   <br />    @Override<br />    public InitialContextFactory createInitialContextFactory(Hashtable environment) throws NamingException {<br />        return this;<br />    }<br /><br />    @Override<br />    public Context getInitialContext(Hashtable environment) throws NamingException {<br />        return context;<br />    }<br /><br />}<br /></pre><br/><h4>4. tomcat-server.xml</h4><h4>&nbsp;</h4>Replace the listener with yours and declare your JNDI resources:  <br /><pre class="brush: xml;"> <br /> &lt;-- Listener className="org.apache.catalina.mbeans.GlobalResourcesLifecycleListener" /&gt;  --&gt;<br /> &lt;Listener className="com.example.catalina.mbeans.GlobalJNDILifecycleListener"/&gt;<br /></pre><pre class="brush: xml;"> <br />&lt;GlobalNamingResources&gt;<br /> &lt;Resource name="jdbc/db"<br />           type="javax.sql.DataSource" username="user" <br />           password="password" <br />           factory="org.apache.tomcat.dbcp.dbcp.BasicDataSourceFactory" <br />           driverClassName="org.postgresql.Driver" <br />           url="jdbc:postgresql://127.0.0.1/db" <br />           maxActive="20" maxIdle="10"/&gt;<br />&lt;/GlobalNamingResources&gt;<br /><br /></pre><br />You can now happily perform plain old new InitialContext().lookup() from every method of every class of your OSGi application deployed in Virgo, regardless of the origin of the thread.  </div>